<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Player - SkyEmu</title>
  <style>
    :root{
      --bg:#0f0f0f;
      --panel:#141414;
      --muted:#bdbdbd;
      --accent:#00aaff;
      --ui-size:14px;
    }
    html,body{
      height:100%;
      margin:0;
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background:var(--bg);
      color:var(--muted);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    /* Top fixed bar that stays visible */
    #topbar{
      position:fixed;
      top:0;
      left:0;
      right:0;
      height:56px;
      display:flex;
      align-items:center;
      gap:12px;
      padding:8px 14px;
      z-index:9999;
      background:linear-gradient(180deg, rgba(0,0,0,0.6), rgba(0,0,0,0.25));
      backdrop-filter: blur(4px);
      box-shadow:0 1px 0 rgba(255,255,255,0.02) inset;
    }
    #back{
      --size:44px;
      display:flex;
      align-items:center;
      justify-content:center;
      width:var(--size);
      height:var(--size);
      border-radius:10px;
      background:transparent;
      color:var(--accent);
      border:1px solid rgba(255,255,255,0.03);
      cursor:pointer;
      font-weight:600;
    }
    #titleBar{
      display:flex;
      flex-direction:column;
      gap:2px;
      min-width:0;
      flex:1;
      overflow:hidden;
    }
    #gameTitle{
      font-size:16px;
      font-weight:700;
      color:#fff;
      white-space:nowrap!important;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width:70%;
    }
    #status{
      font-size:12px;
      color:var(--muted);
      opacity:0.9;
    }

    /* Canvas container - centered and responsive */
    #playerWrap{
      position:fixed;
      top:64px;
      bottom:24px;
      left:0;
      right:0;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:16px;
      box-sizing:border-box;
      overflow:auto;
    }
    canvas#canvas{
      background:#111;
      border-radius:8px;
      box-shadow: 0 6px 30px rgba(0,0,0,0.6);
      max-width:100%;
      max-height:100%;
      width: 800px;
      height: 608px;
      touch-action: none;
      outline: none;
      display:block;
    }

    /* Small bottom sticky controls (kept minimal) */
    #bottomStub{
      position:fixed;
      bottom:12px;
      left:50%;
      transform:translateX(-50%);
      z-index:9998;
      pointer-events:none;
    }

    /* Responsive for small screens / TV */
    @media (max-width:900px){
      canvas#canvas{ width: 92vw; height: 70vh; }
      #gameTitle{ max-width:50%; font-size:15px; }
    }
    @media (max-width:480px){
      #topbar{ height:56px; padding:6px 8px;}
      canvas#canvas{ width: 96vw; height: 60vh; border-radius:6px; }
      #gameTitle{ max-width:60%; font-size:14px; }
      #back{ width:40px; height:40px; border-radius:8px; }
    }

    /* quick helper for hidden elements we inject */
    .hidden-by-playpage{ display:none !important; opacity:0 !important; height:0 !important; width:0 !important; }

    /* style to hide SkyEmu common UI - can be extended */
    #playpage-skyemu-hide-style { /* placeholder injected dynamically */ }
  </style>
</head>
<body>
  <div id="topbar" role="banner" aria-hidden="false">
    <button id="back" title="Torna alla Libreria" aria-label="Torna alla Libreria">‚Üê</button>
    <div id="titleBar">
      <div id="gameTitle">Caricamento...</div>
      <div id="status">Preparazione...</div>
    </div>
  </div>

  <div id="playerWrap" role="main">
    <canvas id="canvas" class="emscripten" tabindex="0"></canvas>
  </div>

  <div id="bottomStub" aria-hidden="true">
    <!-- place for small badges/icons if desired -->
  </div>

  <!-- hidden file input used to feed the emulator -->
  <input id="fileInput0" type="file" accept=".gba,.zip,.bin" style="display:none" />

  <!-- Core emulator official -->
  <script src="https://web.skyemu.app/SkyEmu.js"></script>

  <!-- Aggressive UI-hide & keyboard forwarding + ROM loader -->
  <script>
  (function(){
    "use strict";

    /* ------------------ Utility & layout controls ------------------ */
    const STATUS = document.getElementById('status');
    const TITLE  = document.getElementById('gameTitle');
    const BACK   = document.getElementById('back');
    const CANVAS = document.getElementById('canvas');
    const FILE_INPUT = document.getElementById('fileInput0');

    BACK.addEventListener('click', ()=>{
      if(document.fullscreenElement) document.exitFullscreen().catch(()=>{});
      // go back to index
      window.location.href = "index.html";
    });

    function setStatus(msg){
      STATUS.textContent = msg;
      console.log("[STATUS] " + msg);
    }
    function setTitle(txt){
      TITLE.textContent = txt || "";
      TITLE.title = txt || "";
    }

    /* ------------------ Wait for Module (SkyEmu runtime) ------------------ */
    function waitForModule(timeout = 8000){
      return new Promise((resolve)=>{
        if(window.Module) return resolve(window.Module);
        const start = Date.now();
        const iv = setInterval(()=>{
          if(window.Module){
            clearInterval(iv);
            resolve(window.Module);
          }
          if(Date.now() - start > timeout){
            clearInterval(iv);
            resolve(null);
          }
        }, 100);
      });
    }

    /* ------------------ DOM / UI cleanup (non-destructive) ------------------ */
    const hideTextPatterns = [/skyemu/i, /speed/i, /pause/i, /fps/i, /volume/i, /save/i, /load/i];
    const hideClassCandidates = ['skyemu','sky-ui','emu','toolbar','controls','panel','overlay','speed','menu','branding'];

    // strong css injection for heuristic hiding
    const cssHide = `
      /* aggressive helper rules (safe: highest specificity is our appended style) */
      [class*="sky"], [id*="sky"], [class*="emu"], [id*="emu"], [class*="toolbar"], [class*="control"], [class*="speed"], [id*="branding"], .sky-branding { display:none !important; }
      .hidden-by-playpage{ display:none !important; opacity:0 !important; height:0 !important; width:0 !important; }
    `;
    const styleEl = document.createElement('style');
    styleEl.id = 'playpage-skyemu-hide-style';
    styleEl.appendChild(document.createTextNode(cssHide));
    document.head.appendChild(styleEl);

    function hideNodesByText(root=document.body){
      const nodes = Array.from(root.querySelectorAll('*'));
      nodes.forEach(n=>{
        try{
          if(n === document.body || n === document.documentElement) return;
          if(n.id && /back|topbar|titleBar|status|canvas|playerWrap|fileInput0/i.test(n.id)) return;
          const txt = (n.innerText||'').trim();
          if(!txt) return;
          for(const re of hideTextPatterns){
            if(re.test(txt)){
              n.classList.add('hidden-by-playpage');
              n.style.display = 'none';
              break;
            }
          }
        }catch(e){}
      });
    }

    const mo = new MutationObserver(muts=>{
      muts.forEach(m=>{
        if(m.addedNodes && m.addedNodes.length){
          m.addedNodes.forEach(node=>{
            try{
              if(node.nodeType===1){
                const cls = ((node.className||'') + ' ' + (node.id||'')).toLowerCase();
                for(const c of hideClassCandidates){
                  if(cls.includes(c.toLowerCase())){
                    node.classList.add('hidden-by-playpage');
                    node.style.display = 'none';
                  }
                }
                const txt = (node.innerText||'').trim();
                if(txt){
                  for(const re of hideTextPatterns){
                    if(re.test(txt)){
                      node.classList.add('hidden-by-playpage');
                      node.style.display = 'none';
                      break;
                    }
                  }
                }
              }
            }catch(e){}
          });
        }
      });
    });
    mo.observe(document.body,{childList:true,subtree:true});

    function aggressiveCleanup(){
      try{
        hideNodesByText(document.body);
        // hide any element whose exact innerText is "SkyEmu"
        document.querySelectorAll('div,span,button').forEach(n=>{
          try{
            if((n.innerText||'').trim() === 'SkyEmu'){ n.classList.add('hidden-by-playpage'); n.style.display='none'; }
          }catch(e){}
        });
        // remove title attributes containing skyemu
        document.querySelectorAll('[title],[aria-label]').forEach(n=>{
          try{
            const tit = (n.getAttribute('title')||'') + ' ' + (n.getAttribute('aria-label')||'');
            if(/skyemu/i.test(tit)){ n.classList.add('hidden-by-playpage'); n.style.display='none'; }
          }catch(e){}
        });
      }catch(e){ console.warn('cleanup err', e); }
    }
    // run multiple times to catch late injected UI
    aggressiveCleanup();
    setTimeout(aggressiveCleanup, 700);
    setTimeout(aggressiveCleanup, 2000);

    // Expose a manual helper
    window.removeSkyUI = function(){ aggressiveCleanup(); console.log('removeSkyUI'); };

    /* ------------------ Keyboard forwarding to canvas ------------------ */
    (function setupKeyboardForwarding(){
      try{
        CANVAS.tabIndex = 0;
        CANVAS.setAttribute('tabindex','0');
        CANVAS.style.outline='none';
        CANVAS.addEventListener('mousedown', ()=> CANVAS.focus());
        // Forward keyboard events to canvas so emu receives them
        window.addEventListener('keydown', ev=>{
          // allow browser shortcuts (ctrl, meta) - don't swallow them
          if(ev.ctrlKey || ev.metaKey) return;
          // create a composed KeyboardEvent and dispatch on canvas
          try{
            const evt = new KeyboardEvent('keydown', {
              key: ev.key,
              code: ev.code,
              keyCode: ev.keyCode,
              bubbles: true,
              cancelable: true,
              shiftKey: ev.shiftKey,
              altKey: ev.altKey,
              ctrlKey: ev.ctrlKey,
              metaKey: ev.metaKey,
            });
            CANVAS.dispatchEvent(evt);
          }catch(e){}
        }, {passive:true});
        window.addEventListener('keyup', ev=>{
          if(ev.ctrlKey || ev.metaKey) return;
          try{
            const evt = new KeyboardEvent('keyup', {
              key: ev.key,
              code: ev.code,
              keyCode: ev.keyCode,
              bubbles:true,
              cancelable:true
            });
            CANVAS.dispatchEvent(evt);
          }catch(e){}
        }, {passive:true});
      }catch(e){}
    })();

    /* ------------------ ROM downloading + injection ------------------ */
    // If the ROM is on GitHub raw and CORS blocks, the user must serve from a CORS-enabled host (jsDelivr, catbox, etc).
    // We attempt a normal fetch and report errors to the UI.

    async function fetchArrayBufferWithProgress(url, onProgress){
      // We'll try a standard fetch with CORS mode
      const r = await fetch(url, { mode: 'cors' });
      if(!r.ok) throw new Error("HTTP " + r.status + " " + r.statusText);
      const contentLength = r.headers.get('Content-Length');
      if(!r.body) {
        // no streaming available
        const buf = await r.arrayBuffer();
        onProgress && onProgress(buf.byteLength, buf.byteLength);
        return buf;
      }

      const total = contentLength ? parseInt(contentLength) : undefined;
      const reader = r.body.getReader();
      let received = 0;
      const chunks = [];
      while(true){
        const {done, value} = await reader.read();
        if(done) break;
        chunks.push(value);
        received += value.length;
        onProgress && onProgress(received, total);
      }
      // concatenate
      const tmp = new Uint8Array(received);
      let offset = 0;
      for(const c of chunks){
        tmp.set(c, offset);
        offset += c.length;
      }
      return tmp.buffer;
    }

    function setFileInputFromBuffer(buffer, filename){
      const blob = new Blob([buffer], { type: 'application/octet-stream' });
      const file = new File([blob], filename, { type: 'application/octet-stream' });
      // set into the file input via DataTransfer
      const dt = new DataTransfer();
      dt.items.add(file);
      FILE_INPUT.files = dt.files;
      // dispatch change - SkyEmu listens to file input change to load ROM
      FILE_INPUT.dispatchEvent(new Event('change', { bubbles: true }));
    }

    async function launchROMByUrl(url, displayName){
      try{
        setTitle(displayName || url.split('/').pop());
        setStatus("Scaricamento " + (displayName||"ROM") + "...");
        const buf = await fetchArrayBufferWithProgress(url, (rec, tot)=>{
          if(tot) setStatus(`Scaricato ${Math.round(rec/1024)} KB / ${Math.round(tot/1024)} KB`);
          else setStatus(`Scaricato ${Math.round(rec/1024)} KB`);
        });
        const filename = decodeURIComponent((new URL(url)).pathname.split('/').pop() || 'game.gba');
        setStatus("Preparazione file...");
        setFileInputFromBuffer(buf, filename);
        setStatus("ROM pronta. Avvio emulatore...");
        // hide any status overlay after short delay
        setTimeout(()=>{ STATUS.style.display='none'; }, 800);
        // focus canvas
        try{ CANVAS.focus(); }catch(e){}
      }catch(err){
        console.error(err);
        setStatus("ERRORE: " + (err.message||err));
        // show a helpful hint about CORS if fetch failed
        if(err.message && err.message.toLowerCase().includes('failed to fetch')){
          setStatus("ERRORE: impossibile scaricare (controlla CORS). Usa link con CORS abilitato (catbox/jsdelivr/own host).");
        }
      }
    }

    /* ------------------ Entry: parse params and start ------------------ */
    async function mainEntry(){
      setStatus("Preparazione...");
      const params = new URLSearchParams(location.search);
      const romParam = params.get('rom');
      const idParam  = params.get('id');

      // wait for Module (SkyEmu runtime) to be defined before downloading so that loaded ROM is processed properly.
      const mod = await waitForModule(12000); // wait up to 12s
      if(!mod){
        setStatus("Attenzione: runtime non trovato. Carica la pagina correttamente.");
        // still proceed: we'll try to fetch ROM but emulator may load later
      } else {
        // if Module has print/printErr, override them to avoid on-screen logs (we log to console)
        try{
          if(mod.print) mod.print = function(...a){ console.log('[Module.print]', ...a); };
          if(mod.printErr) mod.printErr = function(...a){ console.error('[Module.printErr]', ...a); };
        }catch(e){}
      }

      // if 'id' provided, try to fetch games.json and map to url
      let romUrl = null;
      let title = null;
      if(idParam){
        setStatus("Caricamento games.json per trovare l'id: " + idParam);
        try{
          // attempt to fetch games.json relative to site root
          const gamesUrl = (new URL('games.json', location.href)).toString();
          const resp = await fetch(gamesUrl, { mode: 'cors' });
          if(!resp.ok) throw new Error("games.json HTTP " + resp.status);
          const list = await resp.json();
          const entry = Array.isArray(list) ? list.find(e=>e.id===idParam) : (list[idParam] || null);
          if(!entry){
            setStatus("ERRORE: id non trovato in games.json");
            console.warn("games.json entries", list);
            return;
          }
          romUrl = entry.url;
          title = entry.name || entry.title || idParam;
        }catch(e){
          console.error(e);
          setStatus("ERRORE caricamento games.json: " + (e.message||e));
          return;
        }
      } else if(romParam){
        // direct rom link
        romUrl = decodeURIComponent(romParam);
      } else {
        setStatus("Nessun ROM specificato. Usa ?rom=URL o ?id=game_id");
        return;
      }

      // If URL is on github raw and you prefer jsDelivr conversion, a simple transform:
      // e.g. https://github.com/user/repo/raw/branch/path/file.gba -> https://cdn.jsdelivr.net/gh/user/repo@branch/path/file.gba
      // but do not auto-rewrite here; let user supply CDN link if CORS issues persist.
      setTitle(title || (romUrl ? romUrl.split('/').pop() : 'ROM'));
      setStatus("Download ROM da: " + romUrl);

      // finally download + inject
      await launchROMByUrl(romUrl, title);
    }

    // start main
    mainEntry();

    // Expose function to programmatically load a rom url
    window.playload = function(url, name){
      launchROMByUrl(url, name);
    };

  })();
  </script>
</body>
</html>
